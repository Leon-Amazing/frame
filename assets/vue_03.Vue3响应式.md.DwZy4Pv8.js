import{_ as o,c as t,o as i,ae as a}from"./chunks/framework.DFXnxiOR.js";const m=JSON.parse('{"title":"Vue3 响应式数据核心","description":"","frontmatter":{},"headers":[],"relativePath":"vue/03.Vue3响应式.md","filePath":"vue/03.Vue3响应式.md"}'),l={name:"vue/03.Vue3响应式.md"};function r(n,e,s,u,c,p){return i(),t("div",null,e[0]||(e[0]=[a('<h1 id="vue3-响应式数据核心" tabindex="-1">Vue3 响应式数据核心 <a class="header-anchor" href="#vue3-响应式数据核心" aria-label="Permalink to &quot;Vue3 响应式数据核心&quot;">​</a></h1><blockquote><p>Vue3 中使用 Proxy 来实现响应式数据变化</p></blockquote><h3 id="compositionapl" tabindex="-1">CompositionAPl <a class="header-anchor" href="#compositionapl" aria-label="Permalink to &quot;CompositionAPl&quot;">​</a></h3><blockquote><p>简单的组件仍然可以采用 OptionsAP!进行编写(但是在 Vue3 中基本不在使用)，compositionAPl 在复杂的逻辑中有着明显的优势~</p></blockquote><ul><li>CompositionAPI 在用户编写复杂业务逻辑不会出现反复横跳问题</li><li>CompositionAPI 不存在 this 指向不明确问题</li><li>Composition APl 对 tree-shaking 更加友好，代码也更容易压缩。CompositionAPI 提取公共逻辑非常方便</li></ul><blockquote><p>reactivity 模块中就包含了很多我们经常使用到的 API 例如:computed、reactive、ref、effect 等</p></blockquote>',6)]))}const d=o(l,[["render",r]]);export{m as __pageData,d as default};
